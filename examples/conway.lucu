import "core:sys/unix"

effect iter {
	fun next() int
}

fun range(start int, end int) iter fails {
	mut cur = start
	handle iter fails {
		fun next() int {
			if cur == end {
				fail
			} else {
				cur++
			}
		}
	}
}

fun init_board() [256]u8 {
	0
}

fun index(x int, y int) usize {
	cast x + y * 16
}

fun dec(n int) int {
	if n == 0 {
		15
	} else {
		n - 1
	}
}

fun inc(n int) int {
	if n == 15 {
		0
	} else {
		n + 1
	}
}

fun print_state(state []u8) / debug {
	with range(0, 16) loop {
		let y = next()
		with range(0, 16) loop {
			let x = next()
			let cell = index(x, y)
			if state[cell] == 0 {
				putstr("ðŸ˜”")
			} else {
				putstr("ðŸ¥º")
			}
		}
		putstr("\n")
	}
}

fun next_state(old []u8, mut new []u8) {
	with range(0, 16) loop {
		let y = next()
		with range(0, 16) loop {
			let x = next()

			mut neighbors = 0
			if old[index(dec(x), dec(y))] > 0 {
				neighbors++
			}
			if old[index(x, dec(y))] > 0 {
				neighbors++
			}
			if old[index(inc(x), dec(y))] > 0 {
				neighbors++
			}
			if old[index(dec(x), y)] > 0 {
				neighbors++
			}
			if old[index(inc(x), y)] > 0 {
				neighbors++
			}
			if old[index(dec(x), inc(y))] > 0 {
				neighbors++
			}
			if old[index(x, inc(y))] > 0 {
				neighbors++
			}
			if old[index(inc(x), inc(y))] > 0 {
				neighbors++
			}

			let cell = index(x, y)
			if old[cell] > 0 {
				if neighbors == 2 {
					new[cell] = 1
				} else if neighbors == 3 {
					new[cell] = 1
				} else {
					new[cell] = 0
				}
			} else if neighbors == 3 {
				new[cell] = 1
			} else {
				new[cell] = 0
			}
		}
	}
}

fun main() / debug unix.sys {
	# create buffers
	mut state = init_board()[0..256]
	mut next = init_board()[0..256]

	# init state
	state[index(0, 0)] = 1
	state[index(1, 1)] = 1
	state[index(2, 1)] = 1
	state[index(0, 2)] = 1
	state[index(1, 2)] = 1

	loop {
		# print state
		print_state(state)

		# wait for stdin
		unix.read([---])

		# get next state
		next_state(state, next)

		# swap buffers
		mut tmp = state
		state = next
		next = tmp
	}
}
