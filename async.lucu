effect write {
	fun write(&s str);
}

effect delay {
	fun wait();
}

fun empty() {}

# effect funcs woop woop

fun wait_write(&s str) / delay write {
	wait()
	write(s)
}

fun main() / write alloc {

	val f = dyn(empty);

	try {

		val s = "Hello, World!\n";
		wait_write(&s);
		
	} with delay {

		fun wait(resume) {
			f = dyn(resume);
		}
		
	};

	f();

}

# after desugaring this becomes (roughly):

fun wait_write(&s str, resume) / delay write {
	wait(fun () / write {
		write(s);
		resume();
	});
}

fun main() / write {

	val f = dyn(empty);

	try {

		val s = "Hello, World!\n";
		wait_write(&s, fun () / write { # &s should point inside the closure of the resume function
			_str_drop(s);
		});
		
	} with delay {

		fun wait(resume) { # resume is an unsized closure (passed by pointer). handlers are evaluated at the bottom of the call stack
			f = dyn(resume);
		}
		
	};

	f();
	
}
